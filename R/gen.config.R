#' Write a configuration to file. Generally used by gen.config()
#' 
#' @param x Parameter sweep results generated by single.predictor()
#' @param v View data frame
#' @param task Task name
#' @param fn.config Filename of the config to be created
write.config <- function(x,v,task,fn.config='config_TEST.txt') {
  ## Things in all view model types
  base::write(paste('data.fn',v,sep='\t'), file=fn.config, append=FALSE)
  base::write(paste('acc',x$Accuracy, sep='\t'), file=fn.config, append=TRUE)
  base::write(paste('taskname',task, sep='\t'), file=fn.config, append=TRUE)
#  base::write(paste('drop','FALSE', sep='\t'), file=fn.config, append=TRUE) # TODO: Commented out for now, suspect I'm going to remove this from platypus altogether

  ## Things specific to this model type (e.g. ntrees)
  if(x$Model=='glmnet') { 
    base::write(paste('type','en', sep='\t'), file=fn.config, append=TRUE)
    base::write(paste('alpha',x$alpha, sep='\t'), file=fn.config, append=TRUE)
    base::write(paste('measure','auc', sep='\t'), file=fn.config, append=TRUE)
  } else if(x$Model=='rf') { 
    base::write(paste('type','rf', sep='\t'), file=fn.config, append=TRUE)
    base::write(paste('mtry',x$mtry, sep='\t'), file=fn.config, append=TRUE)
#    write(paste('ntree',x$ntree, sep='\t'), file=fn.config, append=TRUE) # rf model doesn't have ntree anymore
  } else if(x$Model=='svmRadialCost') { 
    base::write(paste('type','svm', sep='\t'), file=fn.config, append=TRUE)
    base::write(paste('C',x$C, sep='\t'), file=fn.config, append=TRUE)
  } else { message('Model type unknown to platypus.') } #TODO: stop not message?
#
}

#' Generate configuration files for platypus
#'
#' @param view.data List of view data matrices. Must be named.
#' @param tasks File containing all task labels, one column per task
#' @param config.loc Where the config files should be stored
#' @param model.type Type of classifier to use (select from en, rf, svm)
#' @param view.names List of files containing view feature data
#' @param ignore.label Label to ignore in the task file (default 'intermediate')
#'
#' @examples
#' # Create several view/task pairs
#' X1 <- matrix(rnorm(10000), nrow=100)
#' y1 <- c(rep('MOO',50),rep('OINK',50))
#' names(y1) <- paste0('Sample',seq(nrow(X1)))
#' rownames(X1) <- paste0('Sample',seq(nrow(X1)))
#' X2 <- matrix(rnorm(10000), nrow=100)
#' y2 <- c(rep('GROWL',50),rep('RAWR',50))
#' names(y2) <- paste0('Sample',seq(nrow(X2)))
#' rownames(X2) <- paste0('Sample',seq(nrow(X2)))
#' X3 <- matrix(rnorm(10000), nrow=100)
#' y3 <- c(rep('PURR',50),rep('HISS',50))
#' names(y3) <- paste0('Sample',seq(nrow(X3)))
#' rownames(X3) <- paste0('Sample',seq(nrow(X3)))
#' 
#' # Group together view and task data
#' view.data <- list(Farm=X1, Lion=X2, Cat=X3)
#' tasks     <-  do.call("cbind",list(Task1=y1, Task2=y2, Task3=y3))
#' 
#' # Pretend we loaded this data from some files
#' fn.view.names <- list(Farm='Farm.txt', Lion='Lion.txt', Cat='Cat.txt')
#' 
#' # Generate config files
#' gen.config(view.data[1], tasks[,1,drop=FALSE], model.type='en',config.loc='.')
#' gen.config(view.data, tasks, model.type='en', view.names=fn.view.names,config.loc='.')
#' gen.config(view.data, tasks, model.type='en',config.loc='.') 
#' gen.config(view.data, tasks, model.type='svm',config.loc='.')
#' gen.config(view.data, tasks, model.type='rf',config.loc='.')
#' 
#' @return List of config filenames, for use in platypus
#'
#' @export
#gen.config <- function(view.names, fn.tasks, config.loc='config', model.type=c('en','rf','svm'), delim=',', delim.v='\t', n.iters=10, ignore.label='intermediate', nfolds=10, mtry=NA, ntree=c(500,1000,1500,2000)) {
gen.config <- function(view.data, tasks, config.loc='config', model.type=c('en','rf','svm'), view.names=NA, ignore.label='intermediate') {

## Goals:
## view.data is list of data frames (data)
## tasks is list of lists (labels)
## config.loc is path where config files should be stored

  ## For each task - load the task
  ##   For each view - load the view
  ##     Find optimal parameters for view/task pair
  ##     generate config file
  ##     add config filename to return list
  ## return list of config filenames

  ## Make sure model type is in our current list of options
  model.type=match.arg(model.type)  

  ## If view names not provided, make a named list of NA values for it. This is for convenience in code below.
  if(all(is.na(view.names))) {
    view.names <- rep(NA, length(view.data))
    names(view.names) <- names(view.data)
  }

#  ## Set up options
#  alpha.seq <- seq(0.1, 0.9, 0.1)

#  ## Load file with tasks (one task per column, NA/blank values for missing labels)
#  tasks <- utils::read.table(fn.tasks,sep=delim, header=TRUE, row.names=1,check.names=FALSE,stringsAsFactors=FALSE) 

  ## Store list of config filenames for returning
  fns.config <- list()
#  ## Store list of configs for returning
#  configs <- list()

  ## Main loop
  for( v in names(view.data)) {
    print(paste('View',v))
    ## Load the view data
#    X <- utils::read.table(v,sep=delim.v, header=TRUE, row.names=1,check.names=FALSE,stringsAsFactors=FALSE)
    X <- view.data[[v]]
    X <- X[stats::complete.cases(X),]

    ## If view data filenames provided, use those. Otherwise store data to file in same directory as config files, and use that location
    if(is.na(view.names[[v]])) {
      message('Location of this view data file is not provided, therefore storing data matrix to file in same location as configs.')
      v <- paste0(v,'.tsv')
      utils::write.table(X, file=v , sep="\t",row.names=TRUE, col.names=TRUE, quote=FALSE)
    } else {
      v <- view.names[[v]]
    }

    for( task in colnames(tasks) ) {
      print(paste('Task',task))

      ## Use the current task labels - for multiview learning there's just the 1 task
      y <- tasks[,colnames(tasks)==task]
      names(y) <- rownames(tasks)

      ## Set up filename for this config
      fn.config <- switch(model.type,
        en = file.path(config.loc, paste0('config_en_',task,'_',unlist(strsplit(basename(v),'.', fixed=TRUE))[1],'.txt')),
        rf = file.path(config.loc, paste0('config_rf_',task,'_',unlist(strsplit(basename(v),'.', fixed=TRUE))[1],'.txt')),
        svm= file.path(config.loc, paste0('config_svm_',task,'_',unlist(strsplit(basename(v),'.', fixed=TRUE))[1],'.txt'))
      )
      print( paste('Generating config ',fn.config) )
      fns.config <- c(fns.config, fn.config)


      ## Parameter sweep based on task type
      if(model.type=='en') {
        #res <- single.elasticNet.predictor( X, y, alpha = alpha.seq, iterations = n.iters, nfolds=nfolds)
        res <- single.predictor(X,y,model='en')
        print(res)
        write.config(res, v, task, fn.config=fn.config)
        #write.config.en(res, v, task, fn.config=fn.config)
      } else if(model.type=='rf') {
#        if(is.na(mtry)) { mtry <- seq(ceiling(sqrt(ncol(X)))) } # If mtry not provided, use this default
        #res <- single.randomForest.predictor(X, y, mtry=seq(ceiling(sqrt(ncol(X)))) )
        res <- single.predictor(X,y,model='rf')
        print(res)
        write.config(res, v, task, fn.config=fn.config)
        #write.config(res, v, fn.config=fn.config)
        #write.config.rf(res, v, fn.config=fn.config)
      } else if(model.type=='svm') {
        #res <- single.svm.predictor( X, y )
        res <- single.predictor(X,y,model='svm')
        print(res)
        #write.config(res, fn.config=fn.config)
        write.config(res, v, task, fn.config=fn.config)
        #write.config.svm(res, fn.config=fn.config)
      }
      rm(res) 
      
    } # end for tasks
  } # end for views

  print('Finished, success!')
  return(unlist(fns.config))
}
